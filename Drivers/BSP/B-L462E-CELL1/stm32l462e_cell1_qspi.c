/**
  ******************************************************************************
  * @file    stm32l462e_cell1_qspi.c
  * @author  MCD Application Team
  * @brief   This file contains the common functions prototypes for
  *          the QSPI driver. It also contains basic configuration functions in case they have not
  *          been generated by STM32CubeMX tool.
  *          By default, the QSPI configuration uses the files generated by STM32CubeMX tool,
  *          especially redefined weak functions HAL_QSPI_MspInit and HAL_QSPI_MspDeInit.
  *          To use BSP QSPI MSP callbacks, set USE_HAL_QSPI_REGISTER_CALLBACKS to 1U in the
  *          project configuration file stm32l4xx_hal_conf.h
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2018-2021 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "stm32l462e_cell1_qspi.h"

/** @addtogroup BSP BSP
  * @{
  */

/** @addtogroup STM32L462E_CELL1 STM32L462E_CELL1
  * @{
  */

/** @addtogroup STM32L462E_CELL1_QSPI STM32L462E_CELL1 QSPI
  * @{
  */

/** @defgroup STM32L462E_CELL1_QSPI_Exported_Variables STM32L462E_CELL1 QSPI Exported Variables
  * @{
  */

#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
QSPI_HandleTypeDef hqspi;
#endif /* (USE_HAL_QSPI_REGISTER_CALLBACKS == 1) */

/**
  * @}
  */

/** @defgroup STM32L462E_CELL1_QSPI_Exported_Functions STM32L462E_CELL1 QSPI Exported Functions
  * @{
  */

/**
  * @brief  Configure the QSPI interface.
  *         This function is called by BSP_QSPI_Init() and is common to "in module" and "onboard" QSPI.
  * @param  handleQSPI: QSPI handle
  * @param  flashSize: size of QSPI
  * @retval QSPI memory status
  */
int32_t BSP_QSPI_Configuration(QSPI_HandleTypeDef *handleQSPI, uint32_t flashSize)
{
  int32_t ret = BSP_ERROR_COMPONENT_FAILURE;

  /* set QSPI configuration */
  handleQSPI->Instance                = QUADSPI;
  handleQSPI->Init.ClockPrescaler     = 1;
  handleQSPI->Init.FifoThreshold      = 4;
  handleQSPI->Init.SampleShifting     = QSPI_SAMPLE_SHIFTING_NONE;
  handleQSPI->Init.FlashSize          = flashSize;
  handleQSPI->Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_4_CYCLE;
  handleQSPI->Init.ClockMode          = QSPI_CLOCK_MODE_0;
  handleQSPI->Init.FlashID            = QSPI_FLASH_ID_1;
  handleQSPI->Init.DualFlash          = QSPI_DUALFLASH_DISABLE;

  if (HAL_QSPI_Init(handleQSPI) == HAL_OK)
  {
    ret = BSP_ERROR_NONE;
  }

  return (ret);
}


#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
/**
  * @brief Default BSP QSPI Msp Callbacks registration.
  * @retval BSP status
  */
int32_t BSP_QSPI_RegisterDefaultMspCallbacks(void)
{
  static uint32_t IsMspCallbacksValid = 0U;
  int32_t ret = BSP_ERROR_NONE;

  /* Check if the instance is supported */
  if (IsMspCallbacksValid == 0U)
  {
    /* Register MspInit/MspDeInit Callbacks */
    if (HAL_QSPI_RegisterCallback(&hqspi, HAL_QSPI_MSP_INIT_CB_ID, BSP_QSPI_MspInit) != HAL_OK)
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
    }
    else if (HAL_QSPI_RegisterCallback(&hqspi, HAL_QSPI_MSP_DEINIT_CB_ID, BSP_QSPI_MspDeInit) != HAL_OK)
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
    }
    else
    {
      IsMspCallbacksValid = 1U;
    }
  }

  /* Return BSP status */
  return ret;
}

/**
  * @brief BSP QSPI Msp Initialization callback.
  * @param qspiHandle   Handle to QSPI Instance
  * @retval none
  */
void BSP_QSPI_MspInit(QSPI_HandleTypeDef *qspiHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if (qspiHandle->Instance == QUADSPI)
  {
    /* QUADSPI clock enable */
    __HAL_RCC_QSPI_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();

    /**QUADSPI GPIO Configuration
    PA7     ------> QUADSPI_BK1_IO2
    PB1     ------> QUADSPI_BK1_IO0
    PB11     ------> QUADSPI_BK1_NCS
    PB10     ------> QUADSPI_CLK
    PB0     ------> QUADSPI_BK1_IO1
    PA6     ------> QUADSPI_BK1_IO3
      */
    GPIO_InitStruct.Pin = GPIO_PIN_7 | GPIO_PIN_6;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_1 | GPIO_PIN_11 | GPIO_PIN_10 | GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* QUADSPI interrupt Init */
    HAL_NVIC_SetPriority(QUADSPI_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(QUADSPI_IRQn);
  }
}

/**
  * @brief BSP QSPI Msp Deinitialization callback.
  * @param qspiHandle   Handle to QSPI Instance
  * @retval none
  */
void BSP_QSPI_MspDeInit(QSPI_HandleTypeDef *qspiHandle)
{

  if (qspiHandle->Instance == QUADSPI)
  {
    /* Peripheral clock disable */
    __HAL_RCC_QSPI_CLK_DISABLE();

    /**QUADSPI GPIO Configuration
    PA7     ------> QUADSPI_BK1_IO2
    PB1     ------> QUADSPI_BK1_IO0
    PB11     ------> QUADSPI_BK1_NCS
    PB10     ------> QUADSPI_CLK
    PB0     ------> QUADSPI_BK1_IO1
    PA6     ------> QUADSPI_BK1_IO3
      */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_7 | GPIO_PIN_6);

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_1 | GPIO_PIN_11 | GPIO_PIN_10 | GPIO_PIN_0);

    /* QUADSPI interrupt Deinit */
    HAL_NVIC_DisableIRQ(QUADSPI_IRQn);
  }
}
#endif /* (USE_HAL_QSPI_REGISTER_CALLBACKS == 1) */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

